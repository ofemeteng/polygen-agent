import { customActionProvider } from '@coinbase/agentkit';
import { z } from 'zod';
import {
  createThirdwebClient,
  getContract,
  prepareContractCall,
  sendTransaction,
} from "thirdweb";
import { privateKeyToAccount } from "thirdweb/wallets";
import { defineChain } from "thirdweb/chains";
import { upload } from "thirdweb/storage";
import axios from 'axios';

// Schema for the action parameters
const MintNFTSchema = z.object({
  destinationAddress: z
    .string()
    .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address")
    .describe("The Ethereum address where the NFT should be minted to"),
  name: z
    .string()
    .min(1)
    .describe("The name of the NFT"),
  description: z
    .string()
    .optional()
    .describe("Optional description of the NFT. If not provided, will be generated from the name"),
  modelUrl: z
    .string()
    .url()
    .describe("The URL of the 3D model from Meshy AI")
});

export const mintNFT = customActionProvider({
  name: "mint_nft",
  description: "Mints an NFT from the 3D model to the specified address",
  schema: MintNFTSchema,
  invoke: async (_, args: z.infer<typeof MintNFTSchema>) => {
    try {
      // Validate environment variables
      const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS;
      const THIRDWEB_CLIENT_ID = process.env.THIRDWEB_CLIENT_ID;
      const ACCOUNT_PRIVATE_KEY = process.env.ACCOUNT_PRIVATE_KEY || '';

      if (!CONTRACT_ADDRESS || !THIRDWEB_CLIENT_ID || !ACCOUNT_PRIVATE_KEY) {
        throw new Error("Missing required environment variables");
      }

      // create the client with your clientId, or secretKey if in a server environment
      const client = createThirdwebClient({
        clientId: THIRDWEB_CLIENT_ID,
      });

      // connect to your contract
      const contract = getContract({
        client,
        chain: defineChain(84532),
        address: CONTRACT_ADDRESS,
      });

      // Download the 3D model from Meshy AI
      const modelResponse = await axios.get(args.modelUrl, {
        responseType: 'arraybuffer'
      });

      // Create File object from the model data
      const modelFile = new File(
        [modelResponse.data], 
        'model.glb', 
        { type: 'model/gltf-binary' }
      );

      // Upload the 3D model to IPFS
      const modelUri = await upload({
        client,
        files: [modelFile]
      });

      // Prepare metadata
      const metadata = {
        name: args.name,
        description: args.description || `A 3D model of ${args.name.toLowerCase()} generated by Polygen agent.`,
        animation_url: modelUri,
        image: "",
        background_color: "",
        external_url: "",
        customImage: "",
        customAnimationUrl: ""
      };

      // Upload metadata to IPFS
      const metadataUri = await upload({
          client,
          files: [metadata],
        });

      // Mint NFT using the IPFS URI of the metadata
      const transaction = await prepareContractCall({
        contract,
        method:
          "function mintTo(address _to, string _uri) returns (uint256)",
        params: [args.destinationAddress, metadataUri],
      });

      const account = privateKeyToAccount({
        client,
        privateKey: ACCOUNT_PRIVATE_KEY,
      });
      
      const { transactionHash } = await sendTransaction({
        transaction,
        account,
      });

      return JSON.stringify({
        status: "success",
        transactionUri: `https://sepolia.basescan.org/tx/${transactionHash}`,
        metadataUri,
        metadata
      }, null, 2);

    } catch (error) {
      if (error instanceof Error) {
        return `Error minting NFT: ${error.message}`;
      }
      return "An unknown error occurred while minting the NFT";
    }
  }
});